<!DOCTYPE html>
<meta charset="utf-8">
<style>
 
path {
    fill: none;
    stroke: #888;
    stroke-width: .5px;
}
 
.cantons {
    fill: #efefef;
    stroke: none;
}

.canton-boundary {
    stroke-width: 1px;  
}

.land-boundary {
    stroke-width: 2px;
}
 
.municipality-boundary {
    stroke: #aaa;
}

.cantonbubble {
    fill: #667;
}
 
</style>
<body>
<script src="d3.v3.min.js"></script>
<script src="queue.v1.min.js"></script>
<script src="topojson.v0.min.js"></script>
<script>
 
var width = 960,
    height = 500;

var projection = d3.geo.albers()
    .rotate([0, 0])
    .center([8.43, 46.8])
    .scale(13600);

var cantonbubble_radius = d3.scale.linear()
    .range([20, 45]);
 
var path = d3.geo.path()
    .projection(projection);

var force = d3.layout.force()
    .charge(0)
    .gravity(0)
    .size([width, height]);
 
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

queue()
    .defer(d3.json, "switzerland.topo.json")
    .defer(d3.json, "switzerland.geo.json")
    .defer(d3.tsv, "statistiken_2011.kantone.tsv") // TODO load from data directory directly
    .await(ready);
 
foo = null;
bar = null;

function ready(error, topology, canton_shapes, canton_data) {

    /*** SWITZERLAND ***/

    svg.append("path")
        .datum(topojson.object(topology, topology.objects["swiss-cantons"]))
        .attr("d", path)
        .attr("class", "cantons");
   
    /*svg.append("path")
        .datum(topojson.mesh(topology, topology.objects["swiss-municipalities"], function(a, b) { return a.properties.bfsNo !== b.properties.bfsNo }))
        .attr("d", path)
        .attr("class", "municipality-boundary");*/
   
    svg.append("path")
        .datum(topojson.mesh(topology, topology.objects["swiss-cantons"], function(a, b) { return a.properties.no !== b.properties.no}))
        .attr("d", path)
        .attr("class", "canton-boundary");
  
    svg.append("path")
        .datum(topojson.mesh(topology, topology.objects["swiss-cantons"], function(a, b) { return a.properties.no === b.properties.no; }))
        .attr("d", path)
        .attr("class", "land-boundary");


    /*** DORLING CARTOGRAM ***/

    var idToNode = {};
    var links = [];

    var canton_data_map = d3.nest()
        .key(function(e) { return e.abbrev; })
        .map(canton_data);

    max_per_canton = d3.max(canton_data, function(d) { return +d.total_2011; });
    cantonbubble_radius.domain([0, max_per_canton]);

    foo = canton_data;
    bar = cantonbubble_radius;

    var nodes = canton_shapes.features.map(function(d) {
        var xy = projection(d3.geo.centroid(d));
        var value = +canton_data_map[d.properties.abbr][0].total_2011;
        return idToNode[d.id] = {
            x: xy[0],
            y: xy[1],
            gravity: {x: xy[0], y: xy[1]},
            r: cantonbubble_radius(value),
            value: value
        };
    });

    force
        .nodes(nodes)
        .links(links)
        .start()
        .on("tick", function(e) {
            var k = e.alpha,
                kg = k * .02;
            nodes.forEach(function(a, i) {
                // Apply gravity forces
                a.x += (a.gravity.x - a.x) * kg;
                a.y += (a.gravity.y - a.y) * kg;
                nodes.slice(i + 1).forEach(function(b) {
                    // Check for collisions
                    var dx = a.x - b.x,
                        dy = a.y - b.y,
                        l = Math.sqrt(dx * dx + dy * dy),
                        d = a.r + b.r;
                    if (l < d) {
                        l = (l - d) / l * k;
                        dx *= l;
                        dy *= l;
                        a.x -= dx;
                        a.y -= dy;
                        b.x += dx;
                        b.y += dy;
                    }
                });
            });

            svg.selectAll("circle")
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });
        });

    svg.selectAll("circle")
        .data(nodes)
      .enter()
        .append("circle")
        .attr("class", "cantonbubble")
        .attr("cx", function (d) { return d.x; })
        .attr("cy", function (d) { return d.y; })
        .attr("r", function (d) { return d.r; });
};
 
</script>
